<!DOCTYPE html>
<html>
    <head>
        <!--
        * Author:         Lyruse
        -->
        <meta charset="utf-8" />
        <title>Y组合子的实现 | Lyruse.com</title>
        <meta name="author" content="Lyruse" />
        <meta name="description" content="Lyruse's Blog" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
        <link rel="stylesheet" href="/css/default.css" type="text/css" />
        <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    </head>
<body>
    <div class="home-menu">
        <div class="home-icon-con">
            <a class="home-menu-icon" href="/">Lyruse</a>

        </div>
    </div>

    <link rel="stylesheet" href="/css/monokai.css" />
<style type="text/css">
    body { background:#e8e8e8; }
    @media screen and (max-width: 750px){
        body { background:#fff; }
    }
    @media screen and (max-width: 1020px){
        body { background:#fff; }
    }
</style>

<div id="content">
    <div class="entry">
        <h1 class="entry-title">Y组合子的实现</h1>
        <p class="entry-date">2014-12-16</p>
        <p>第一次接触到王垠的博文的时候，就被他骄傲的态度给征服了，心想他该是有多么的能力非凡才能语出惊人啊。然后追随他的脚步，开始了掌握Scheme（lisp的一种方言）的漫长之路，可是书看了不少，却没有认真的总结与记录，从没有认真为Lisp写过一篇文章。我想这有点不符合Lisp爱好者的身份，就打起精神写一篇关于Y组合子的文章吧。于是就有了本文。</p>

<h2 id="准备知识">准备知识</h2>

<p>这里使用的语言是Lisp，而且只用最基本的语法来进行讲解。</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">arg</span><span class="p">)</span> <span class="nv">arg</span><span class="p">)</span>  <span class="c1">;;identity 函数，把输入函数的参数直接返回</span>

<span class="p">(</span><span class="nf">cond</span>
    <span class="p">[(</span><span class="nb">zero? </span><span class="mi">0</span><span class="p">)</span> <span class="mi">0</span><span class="p">]</span>   <span class="c1">;;条件分支语句，用来进行情况分类，[]里的第一个</span>
                    <span class="c1">;;()的值用来判断真假，然后计算()后面的表达式，即是0；</span>
    <span class="p">[</span><span class="k">else </span><span class="mi">1</span><span class="p">])</span>       <span class="c1">;;else表示这条分支的条件是true，如前面都没有true值，</span>
                    <span class="c1">;;那就会执行这条语句。</span>

<span class="c1">;;lisp里面只有表达式，而表达式可以直接多层嵌套，而函数和操作符全部放在</span>
<span class="c1">;;表达式的前面，表示要对接下来的参数进行处理。</span>

<span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="k">if </span><span class="nv">true</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">;;这样的表达式在某些lisp实现里也是有效的，尽管</span>
                            <span class="c1">;;if是单臂的。</span>
                            <span class="c1">;;0 和 1 是语言的内置对象，可以直接使用</span>

<span class="p">(</span><span class="k">define </span><span class="nv">one</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1">;;使用define来进行var的绑定。</span></code></pre></figure>

<p>下面定义一个计算n的阶乘的函数：</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="k">define </span><span class="nv">n!</span>      <span class="c1">;;把n!绑定为一个函数</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">cond</span>
            <span class="p">[(</span><span class="nb">zero? </span><span class="nv">n</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
            <span class="p">[</span><span class="k">else </span><span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">n!</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))])))</span>  <span class="c1">;*为乘法运算，(* 5 4)表示5*4</span>
                                          <span class="c1">;-为减法运算，(- n 1)表示n-1</span>
<span class="p">(</span><span class="nf">n!</span> <span class="mi">3</span><span class="p">)</span>          <span class="c1">;;计算3的阶乘</span>

<span class="c1">;;计算过程是下面这样</span>
<span class="p">(</span><span class="nf">cond</span>
  <span class="p">[(</span><span class="nb">zero? </span><span class="mi">3</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
  <span class="p">[</span><span class="k">else </span><span class="p">(</span><span class="nb">* </span><span class="mi">3</span> <span class="p">(</span><span class="nf">cond</span>
               <span class="p">[(</span><span class="nb">zero? </span><span class="mi">2</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
               <span class="p">[</span><span class="k">else </span><span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="p">(</span><span class="nf">cond</span>
                            <span class="p">[(</span><span class="nb">zero? </span><span class="mi">1</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
                            <span class="p">[</span><span class="k">else </span><span class="p">(</span><span class="nb">* </span><span class="mi">1</span> <span class="p">(</span><span class="nf">cond</span>
                                         <span class="p">[(</span><span class="nb">zero? </span><span class="mi">0</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
                                         <span class="p">[</span><span class="k">else </span><span class="o">...</span><span class="p">]))]))]))])</span>

<span class="c1">;; ==&gt; (* 3 (* 2 (* 1 1)))</span>
<span class="c1">;; 当(lambda (n) ...) 被传参数的时候，函数体里面的表达式就会被展开</span>
<span class="c1">;; 上面的过程就是n!被传3的时候的展开过程，而根据条件表达式的短路设置</span>
<span class="c1">;; ... 表示的内容根本不会被展开。</span></code></pre></figure>

<p>下面再定义一个<code>eternity</code>函数作为helper，把任何值作为输入，它都不会返回值，是一个partial function，means never return a value.</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="k">define </span><span class="nv">eternity</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">eternity</span> <span class="nv">x</span><span class="p">)))</span>   <span class="c1">;;虽然这个函数内部使用自身，但我们只是用这个函数</span>
                       <span class="c1">;;来帮助我们理解Y的生成过程的</span></code></pre></figure>

<p>我们可以看到在展开的过程中，函数不断的调用自身，然后不断的展开，知道最后到达了终止clause，这里有个递归的原则，就是在递归的过程中，传递的参数一定要不断的接近终止条件，在上面的例子中就是n的值不断减少，直至最后为0。这里在定义函数的时候，函数体里面直接引用了<code>n!</code>作为函数调用，可是如果没有<code>define</code>这个语言内置的语法，在函数体内我们不再能引用<code>n!</code>,我们怎么实现这个递归调用的函数呢？这里就要用到一种称为Y combinator的技术了。</p>

<h2 id="把递归函数作为值传进函数">把递归函数作为值传进函数</h2>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="k">define </span><span class="nv">n0!</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">cond</span>
      <span class="p">[(</span><span class="nb">zero? </span><span class="nv">n</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
      <span class="p">[</span><span class="k">else </span><span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">eternity</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))])))</span></code></pre></figure>

<p>这个函数只有当输入值为0时，才有返回值1，输入别的任何的值都没有结果，因为在判断出来不是0的时候，就进入了<code>eternity</code>的内部了，永久循环。</p>

<p>那么我们怎么定义一个函数可以计算<code>0</code>或者<code>1</code>的阶乘呢？我们可不可以直接把<code>n0!</code>代入刚刚<code>eternity</code>的位置呢？而且因为我们没有<code>define</code>，不能直接写<code>n0!</code>上去，我们直接把函数体写上去。</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="k">define </span><span class="nv">n&lt;=1!</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">cond</span>
      <span class="p">[(</span><span class="nb">zero? </span><span class="nv">n</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
      <span class="p">[</span><span class="k">else </span><span class="p">(</span><span class="nb">* </span><span class="nv">n</span>
              <span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span> <span class="c1">;; n0!的函数体开始</span>
                 <span class="p">(</span><span class="nf">cond</span>
                   <span class="p">[(</span><span class="nb">zero? </span><span class="nv">n</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
                   <span class="p">[</span><span class="nv">else</span>
                     <span class="p">(</span><span class="nb">* </span><span class="nv">n</span>
                      <span class="p">(</span><span class="nf">eternity</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))]))</span> <span class="c1">;; n0!  结束</span>
               <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))]))))</span></code></pre></figure>

<p>这样我们就得到了一个可以计算0..1的阶乘函数了。大于1的值会得不到结果。那么按照这个模式，如果我们把<code>n&lt;=1!</code>替换<code>eternity</code>放进去<code>n0!</code>的函数体里面是不是相应的就得到了<code>n&lt;=2!</code>，可以计算等于小于2的阶乘了呢。</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="k">define </span><span class="nv">n&lt;=2!</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">cond</span>
      <span class="p">[(</span><span class="nb">zero? </span><span class="nv">n</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
      <span class="p">[</span><span class="k">else </span><span class="p">(</span><span class="nb">* </span><span class="nv">n</span> 
               <span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>    <span class="c1">;; n1! start</span>
                  <span class="p">(</span><span class="nf">cond</span>
                    <span class="p">[(</span><span class="nb">zero? </span><span class="nv">n</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="p">[</span><span class="k">else </span><span class="p">(</span><span class="nb">* </span>
                            <span class="nv">n</span>
                            <span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span> <span class="c1">;; n0!的函数体开始</span>
                               <span class="p">(</span><span class="nf">cond</span>
                                 <span class="p">[(</span><span class="nb">zero? </span><span class="nv">n</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
                                 <span class="p">[</span><span class="nv">else</span>
                                   <span class="p">(</span><span class="nb">* </span><span class="nv">n</span>
                                      <span class="p">(</span><span class="nf">eternity</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))]))</span> <span class="c1">;; n0!  结束</span>
                             <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))]))</span>
                <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))])))</span></code></pre></figure>

<p>通过上面的介绍，我们首先定义了一个可以计算0的阶乘函数，然后再定义了0..1的阶乘函数，再然后0..2的阶乘函数，通过把新定义好的函数直接放进去<code>n0!</code>函数体里面的<code>eternity</code>就是可以计算比原来函数的输入多1的阶乘函数了。如果我们可以定义一个无穷函数，用的结构跟上面定义的函数一样，那么我们是不是就得到了一个完整的<code>n!</code>函数呢。</p>

<p>可以阶乘函数的输入可以为0，也可以为100，也可以是很大很大的一个整数，可我们无法写一个不断套用同一个结构的函数，虽然他们的代码都是重复再重复的。这时候，我们就要想，有什么方法可以复用这种重复的代码结构，而不用手写那样笨，这就体现了软件设计思想里面的 DRY(Don’t repeat yourself)</p>
<h2 id="抽象出n函数">抽象出<code>n&lt;=?!</code>函数</h2>

<p>由于这些函数都有一个共同的特征，那就是都在函数里里包含有一个看似<code>n!</code>的函数。</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n!</span><span class="p">)</span>     <span class="c1">;; 展开后成为 n0! 函数</span>
   <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">cond</span>
       <span class="p">[(</span><span class="nb">zero? </span><span class="nv">n</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
       <span class="p">[</span><span class="k">else </span><span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">n!</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))])))</span>
 <span class="nv">eternity</span><span class="p">)</span></code></pre></figure>

<p>上面的函数把参数eternity传进函数体内，得到的结果就是前面写过的<code>n0!</code>。</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">f</span><span class="p">)</span>        <span class="c1">;; 函数 n1!</span>
   <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">cond</span>
       <span class="p">[(</span><span class="nb">zero? </span><span class="mi">0</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
       <span class="p">[</span><span class="k">else </span><span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))])))</span>
 <span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n!</span><span class="p">)</span>      <span class="c1">;; 函数 n0!</span>
   <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">cond</span>
       <span class="p">[(</span><span class="nb">zero? </span><span class="nv">n</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
       <span class="p">[</span><span class="k">else </span><span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">n!</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))])))</span>
  <span class="nv">eternity</span><span class="p">))</span>

<span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">f</span><span class="p">)</span>         <span class="c1">;; 函数 n&lt;=2!</span>
   <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">cond</span>
       <span class="p">[(</span><span class="nb">zero? </span><span class="nv">n</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
       <span class="p">[</span><span class="k">else </span><span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))])))</span>
 <span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">f</span><span class="p">)</span>        <span class="c1">;; 函数 n&lt;=1!</span>
   <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">cond</span>
       <span class="p">[(</span><span class="nb">zero? </span><span class="mi">0</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
       <span class="p">[</span><span class="k">else </span><span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))])))</span>
  <span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n!</span><span class="p">)</span>      <span class="c1">;; 函数 n0!</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">cond</span>
        <span class="p">[(</span><span class="nb">zero? </span><span class="nv">n</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
        <span class="p">[</span><span class="k">else </span><span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">n!</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))])))</span>
  <span class="nv">eternity</span><span class="p">)))</span></code></pre></figure>

<p>看到上面的这些函数，感觉是不是很多repetition很多呢，我们想想办法看看，能不能把它们给去除，抽取出模式。那我们能怎么做呢？</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">f</span><span class="p">)</span>       
   <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">cond</span>
       <span class="p">[(</span><span class="nb">zero? </span><span class="nv">n</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
       <span class="p">[</span><span class="k">else </span><span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))])))</span></code></pre></figure>

<p>我们可以观察到，上面这个函数是不是反复的出现呢？我们怎么样可以把它抽象为一个变量，然后可以反复使用呢？这时我们就想到了lambda，lambda就是可以把传进来的参数绑定到一个变量，然后在lambda的体内尽情的使用。</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">mk-n!</span><span class="p">)</span>        <span class="c1">;; this is n0!</span>
   <span class="p">(</span><span class="nf">mk-n!</span> <span class="nv">eternity</span><span class="p">))</span>
 <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n!</span><span class="p">)</span>
   <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">cond</span>
       <span class="p">[(</span><span class="nb">zero? </span><span class="nv">n</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
       <span class="p">[</span><span class="k">else </span><span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">n!</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))]))))</span>


<span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">mk-n!</span><span class="p">)</span>        <span class="c1">;; this is n&lt;=1!</span>
   <span class="p">(</span><span class="nf">mk-n!</span>
     <span class="p">(</span><span class="nf">mk-n!</span>             <span class="c1">;; this is n0!</span>
       <span class="nv">eternity</span><span class="p">)))</span>
 <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n!</span><span class="p">)</span>
   <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">cond</span>
       <span class="p">[(</span><span class="nb">zero? </span><span class="nv">n</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
       <span class="p">[</span><span class="k">else </span><span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">n!</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))]))))</span>


<span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">mk-n!</span><span class="p">)</span>        
   <span class="p">(</span><span class="nf">mk-n!</span>                 <span class="c1">;; this is n&lt;=2!</span>
     <span class="p">(</span><span class="nf">mk-n!</span>               <span class="c1">;; this is n&lt;=1!</span>
       <span class="p">(</span><span class="nf">mk-n!</span>             <span class="c1">;; this is n0!</span>
         <span class="nv">eternity</span><span class="p">))))</span>
 <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n!</span><span class="p">)</span>
   <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">cond</span>
       <span class="p">[(</span><span class="nb">zero? </span><span class="nv">n</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
       <span class="p">[</span><span class="k">else </span><span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">n!</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))]))))</span></code></pre></figure>

<p>这样一简化后，看起来是不是清爽很多了呢。如果我们要计算更大的n的阶乘，我们只需要加多一层<code>mk-n!</code>就可以实现了。这时候的递归就像是让<code>mk-n!</code>首先接受一个随便什么函数，然后就堆叠起一个无限的<code>mk-n!</code>套套套的函数。可是我们并不需要一个无限的套起来的函数，我们计算阶乘的时候都是只需要一个确切的堆叠层数就够了，不过我们永远不知道这个数字到底是多少。如果我们只堆叠了10个<code>mk-n!</code>，当要计算10的阶乘的时候，我们就会调用到最里边的那个<code>mk-n!</code>，并且使用到eternity来进行计算，结果就是永久循环。</p>

<p>有没有什么办法一劳永逸的解决这个问题，不用一直重复写<code>mk-n!</code>，并且担心会不够的情况出现。</p>

<h2 id="再次抽象">再次抽象</h2>

<p>我们可以看看，<code>n0!</code>的时候我们根本不担心传进来的<code>f</code>到底是什么，因为如果传进来的是<code>0</code>，我们根本就没有机会调用到<code>f</code>这个函数。那我们可不可以直接把<code>mk-n!</code>作为参数传进<code>mk-n!</code>呢？</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">mk-n!</span><span class="p">)</span>        <span class="c1">;; this is n0!</span>
   <span class="p">(</span><span class="nf">mk-n!</span> <span class="nv">mk-n!</span><span class="p">))</span>
 <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n!</span><span class="p">)</span>
   <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">cond</span>
       <span class="p">[(</span><span class="nb">zero? </span><span class="nv">n</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
       <span class="p">[</span><span class="k">else </span><span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">n!</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))]))))</span>
       <span class="c1">;;           ^</span>
       <span class="c1">;;           |</span>
       <span class="c1">;;          here</span>
       </code></pre></figure>

<p>函数这样写了之后会有什么效果呢？这不就是自己调用自己嘛。可是一旦输入的数超过<code>0</code>，函数就出现问题了，因为这时候<code>n!</code>绑定为</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n!</span><span class="p">)</span>
   <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">cond</span>
       <span class="p">[(</span><span class="nb">zero? </span><span class="nv">n</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
       <span class="p">[</span><span class="k">else </span><span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">n!</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))])))</span></code></pre></figure>

<p>它首先要接收一个函数才行啊，作为如果当前要处理的数不为0时的候补处理。这时候就要想办法修改<code>here</code>（上面程序标注着here的地方）才行了。那如果<code>(mk-n!  mk-n!)</code>能够处理<code>0</code>的阶乘，那<code>here</code>这个地方能不能也放上<code>(mk-n! mk-n!)</code>呢？</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">mk-n!</span><span class="p">)</span>        <span class="c1">;; this is n0!</span>
   <span class="p">(</span><span class="nf">mk-n!</span> <span class="nv">mk-n!</span><span class="p">))</span>
 <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">mk-n!</span><span class="p">)</span>
   <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">cond</span>
       <span class="p">[(</span><span class="nb">zero? </span><span class="nv">n</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
       <span class="p">[</span><span class="k">else </span><span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">((</span><span class="nf">mk-n!</span> <span class="nv">mk-n!</span><span class="p">)</span>
                    <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))]))))</span></code></pre></figure>

<p>当函数变成这个样子后，我们惊奇的发现，它竟然能处理大于<code>1</code>的阶乘了，当程序流程到了<code>here</code>这个地方，<code>(mk-n!  mk-n!)</code>又自动的生成了一个可以处理大于<code>1</code>的阶乘函数了。</p>

<p>可是这样子跟我们一开始定义<code>n!</code>的结构不一样了啊。那我们能不能把移出来作为函数传递进入呢。</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">mk-n!</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">mk-n!</span> <span class="nv">mk-n!</span><span class="p">))</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">mk-n!</span><span class="p">)</span>
    <span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n!</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">cond</span>
           <span class="p">[(</span><span class="nb">zero? </span><span class="nv">n</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
           <span class="p">[</span><span class="k">else </span><span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">n!</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))])))</span>
     <span class="p">(</span><span class="nf">mk-n!</span> <span class="nv">mk-n!</span><span class="p">))))</span>


<span class="p">(((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">mk-n!</span><span class="p">)</span>    <span class="c1">;; use this function to 1 </span>
    <span class="p">(</span><span class="nf">mk-n!</span> <span class="nv">mk-n!</span><span class="p">))</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">mk-n!</span><span class="p">)</span>
    <span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n!</span><span class="p">)</span>
       <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
         <span class="p">(</span><span class="nf">cond</span>
           <span class="p">[(</span><span class="nb">zero? </span><span class="nv">n</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
           <span class="p">[</span><span class="k">else </span><span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">n!</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))])))</span>
     <span class="p">(</span><span class="nf">mk-n!</span> <span class="nv">mk-n!</span><span class="p">))))</span>
 <span class="mi">1</span><span class="p">)</span></code></pre></figure>

<p>当我们应用这个函数到<code>1</code>的时候，我们会发现由于Lisp语言是Call-By-Value的，<code>(mk-n! mk-n!)</code>会永远计算不出结果，陷入无限循环之中。就像下面的展开过程一样。</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n!</span><span class="p">)</span>
   <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">cond</span>
       <span class="p">[(</span><span class="nb">zero? </span><span class="nv">n</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
       <span class="p">[</span><span class="k">else </span><span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">n!</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))])))</span>
 <span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n!</span><span class="p">)</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">cond</span>
        <span class="p">[(</span><span class="nb">zero? </span><span class="nv">n</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
        <span class="p">[</span><span class="k">else </span><span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">n!</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))])))</span>
  <span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n!</span><span class="p">)</span>
     <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">cond</span>
         <span class="p">[(</span><span class="nb">zero? </span><span class="nv">n</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
         <span class="p">[</span><span class="k">else </span><span class="p">(</span><span class="nb">* </span><span class="nv">n</span> <span class="p">(</span><span class="nf">n!</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))])))</span>
   <span class="p">(</span><span class="nf">mk-n!</span> <span class="nv">mk-n!</span><span class="p">))))</span></code></pre></figure>

<p>我们可以看到这样会一直循环下去，永远没有结果。那我们要回到原点，回到当初还正确的地方，<code>(mk-n! mk-n!)</code>就是没有把提取出来的那个地方，我们想象怎么样才可以延迟它的计算，让它在需要的时候才进行展开。很自然的我们想到了给它加上一个<code>lambda</code>,那样就可以延迟计算，让它在需要的时候再传递参数进去进行计算。</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">mk-n!</span><span class="p">)</span>     
   <span class="p">(</span><span class="nf">mk-n!</span> <span class="nv">mk-n!</span><span class="p">))</span>
 <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">mk-n!</span><span class="p">)</span>
   <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">cond</span>
       <span class="p">[(</span><span class="nb">zero? </span><span class="nv">n</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
       <span class="p">[</span><span class="k">else </span><span class="p">(</span><span class="nb">* </span><span class="nv">n</span> 
                <span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> 
                   <span class="p">((</span><span class="nf">mk-n!</span> <span class="nv">mk-n!</span><span class="p">)</span> <span class="nv">x</span><span class="p">))</span>
                 <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))]))))</span>
                    
<span class="c1">;; 然后把函数提取出来，给它一个名字，套进一个lambda中。</span>
<span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">mk-n!</span><span class="p">)</span>     
   <span class="p">(</span><span class="nf">mk-n!</span> <span class="nv">mk-n!</span><span class="p">))</span>
 <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">mk-n!</span><span class="p">)</span>
   <span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n!</span><span class="p">)</span> 
      <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">cond</span>
          <span class="p">[(</span><span class="nb">zero? </span><span class="nv">n</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
          <span class="p">[</span><span class="k">else </span><span class="p">(</span><span class="nb">* </span><span class="nv">n</span> 
                   <span class="p">(</span><span class="nf">n!</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))])))</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> 
      <span class="p">((</span><span class="nf">mk-n!</span> <span class="nv">mk-n!</span><span class="p">)</span> <span class="nv">x</span><span class="p">)))))</span></code></pre></figure>

<p>至此我们已经完成了构造一个可递归的<code>n!</code>的函数了，接下来我们可以把这种可以把普通函数变成递归函数的模式抽象出来，那样以后直接用于普通函数，就可以直接生成可递归的函数了。</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">f</span><span class="p">)</span>
   <span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">mk-n!</span><span class="p">)</span>     
      <span class="p">(</span><span class="nf">mk-n!</span> <span class="nv">mk-n!</span><span class="p">))</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">mk-n!</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">f</span>
        <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> 
          <span class="p">((</span><span class="nf">mk-n!</span> <span class="nv">mk-n!</span><span class="p">)</span> <span class="nv">x</span><span class="p">))))))</span>
 <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n!</span><span class="p">)</span> 
   <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span>
     <span class="p">(</span><span class="nf">cond</span>
       <span class="p">[(</span><span class="nb">zero? </span><span class="nv">n</span><span class="p">)</span> <span class="mi">1</span><span class="p">]</span>
       <span class="p">[</span><span class="k">else </span><span class="p">(</span><span class="nb">* </span><span class="nv">n</span> 
                <span class="p">(</span><span class="nf">n!</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))]))))</span>
<span class="c1">;; ==&gt;</span>

<span class="p">(</span><span class="k">define </span><span class="nv">Y</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">f</span><span class="p">)</span>
    <span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">mk</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">mk</span> <span class="nv">mk</span><span class="p">))</span>
     <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">((</span><span class="nf">mk</span> <span class="nv">mk</span><span class="p">)</span> <span class="nv">x</span><span class="p">))))))</span></code></pre></figure>

<p>这里提取出来的模式就是applicative-order Y combinator.</p>

<p>妈的，真他妈的累，在Vim里面编辑MD文档会出现莫名其妙的错误，而且中文和英文的转换好不方便。</p>

<p>下次要编写代码的，直接使用Markdown编辑器好了。</p>


    <!-- here's for comment module, but now I don't need it.-->
    </div>

    <div class="sidenav">
      <h2>技术</h2>
      <ul class="artical-list">
        
        <li><a href="/eng/2015/02/27/anf-conversion//">ANF 转换实现</a></li>
        
        <li><a href="/eng/2015/02/07/exception//">异常(exception)的实现</a></li>
        
        <li><a href="/eng/2015/01/21/ooo//">面向对象的实现(Object Oriented Style)</a></li>
        
        <li><a href="/eng/2014/12/16/halting-problem//">停机问题（即不完备定理）</a></li>
        
        <li><a href="/eng/2014/12/16/Y-conbinator//">Y组合子的实现</a></li>
        
        <li><a href="/eng/2014/12/14/a-thought-about-bug//">关于使用软件的一点小想法</a></li>
        
      </ul>
      <h2>杂谈</h2>
      <ul class="artical-list">
        
        <li><a href="/blog/2015/09/04/open-relationship//">开放式关系</a></li>
        
        <li><a href="/blog/2015/09/04/deduction-and-induction//">思考的模式</a></li>
        
        <li><a href="/blog/2015/02/22/about-new-year//">2015新年随想</a></li>
        
        <li><a href="/blog/2015/02/09/sex-and-love//">性、爱情与婚姻</a></li>
        
        <li><a href="/blog/2015/01/14/current-love//">好美系列：一（早见明里）</a></li>
        
        <li><a href="/blog/2015/01/11/love-and-freedom//">爱与自由</a></li>
        
        <li><a href="/blog/2014/12/15/process-dealing-with-pages//">转变</a></li>
        
        <li><a href="/blog/2014/12/13/rebuild//">重构</a></li>
        
        <li><a href="/blog/2014/04/16/bad-health-lead-to-nothing//">身体是前提</a></li>
        
        <li><a href="/blog/2014/02/19/find-the-right-one//">三观合，生活舒适</a></li>
        
        <li><a href="/blog/2014/02/08/my-first-blog//">我存在</a></li>
        
      </ul>
    </div>

    <div id="navigator" >
      <a id="next" href="/eng/2014/12/16/halting-problem/">&lt;&lt;newer 停机问题（即不完备定理）</a>
      |
      <a id="previous" href="/blog/2014/12/15/process-dealing-with-pages/">转变&gt;&gt;</a>
    </div>

</div>

<script src="/js/jquery-1.7.1.min.js" type="text/javascript"></script>
<script src="/js/post.js" type="text/javascript"></script>


